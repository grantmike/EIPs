---
eip: 5828
title: Permissionless Transfer With Authorization
author: Michael Grant (@grantmike)
status: Draft
type: Standards Track
category: ERC
created: 2022-11-16
requires: 20, 712, 3009
---

## Simple Summary

A contract interface that enables transferring of fungible assets via a signed authorization while atomically paying permissionless relayer. 

## Abstract

A set of functions to enable meta-transactions and atomic interactions with [ERC-20](./eip-20.md) token contracts via signatures conforming to the [EIP-712](./eip-712.md) typed message signing specification.

This enables the user to do _everything_ enabled in [EIP-3009](./eip-3009), while also incentivizing _anyone_ to relay the user's meta-transaction.

## Motivation

The biggest issue with EIP-3009 is that relayers have no built-in incentive to relay meta transactions for anonymous users. If a user wants to leverage EIP-3009 to only pay network fees using something like USDC, the user must find a relayer willing to pay the gas fees on their behalf and setup some off-chain agreement to reimburse the relayer for the ETH gas fees incurred on tx submission.

Due to the soft requirement of an off-chain relationship between user and relayer, the end result is often a semi-custodial solution which introduces friction for mass adoption of ERC-20 as a payment instrument.  

## Specification

For simplicity, this EIP does not cover fields that are already explained in EIP-3009. To see the 13-line diff of the proposed changes to EIP-3009, please reference this [PR](https://github.com/grantmike/EIPs/pull/2).      

### Event

```solidity

// keccak256("PermissionlessTransferWithAuthorization(address from,address to,uint256 value,uint256 relayerValue,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
bytes32 public constant PERMISSIONLESS_TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x36722d65618feba7c8a419b660c58297bb8774ab92daa05ab9d80f3a42320b3e;

/**
 * @notice Execute a transfer with a signed authorization
 * @param from          Payer's address (Authorizer)
 * @param to            Payee's address
 * @param value         Amount to be transferred
 * @param relayerValue  Amount to be transferred to msg.sender
 * @param validAfter    The time after which this is valid (unix time)
 * @param validBefore   The time before which this is valid (unix time)
 * @param nonce         Unique nonce
 * @param v             v of the signature
 * @param r             r of the signature
 * @param s             s of the signature
 */
function permissionlessTransferWithAuthorization(
    address from,
    address to,
    uint256 value,
    uint256 relayerValue,
    uint256 validAfter,
    uint256 validBefore,
    bytes32 nonce,
    uint8 v,
    bytes32 r,
    bytes32 s
) external;

```

**Example:**

```
// Permissionless Transfer With Authorization
TypeHash := Keccak256(
  "PermissionlessTransferWithAuthorization(address from,address to,uint256 value,uint256 relayerValue,uint256 validAfter,uint256 validBefore,bytes32 nonce)"
)
Params := { From, To, Value, RelayerValue, ValidAfter, ValidBefore, Nonce }
```

### Use with web3 providers

The signature for an authorization can be obtained using a web3 provider with the `eth_signTypedData{_v4}` method.

**Example:**

```javascript
const data = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
    ],
    PermissionlessTransferWithAuthorization: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" }, 
      { name: "relayerValue", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" },
    ],
  },
  domain: {
    name: tokenName,
    version: tokenVersion,
    chainId: selectedChainId,
    verifyingContract: tokenAddress,
  },
  primaryType: "PermissionlessTransferWithAuthorization",
  message: {
    from: userAddress,
    to: recipientAddress,
    value: amountBN.toString(10),
    relayerValue: relayerAmountBN.toString(10),
    validAfter: 0,
    validBefore: Math.floor(Date.now() / 1000) + 3600, // Valid for an hour
    nonce: Web3.utils.randomHex(32),
  },
};

const signature = await ethereum.request({
  method: "eth_signTypedData_v4",
  params: [userAddress, JSON.stringify(data)],
});

const v = "0x" + signature.slice(130, 132);
const r = signature.slice(0, 66);
const s = "0x" + signature.slice(66, 130);
```

## Implementation

**EIP5828.sol**
```solidity
abstract contract EIP5828 is IERC20Transfer, EIP712Domain {
    // keccak256("PermissionlessTransferWithAuthorization(address from,address to,uint256 value,uint256 relayerValue,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
    bytes32 public constant PERMISSIONLESS_TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x36722d65618feba7c8a419b660c58297bb8774ab92daa05ab9d80f3a42320b3e;

    function permissionlessTransferWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 relayerValue,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(now > validAfter, "EIP5828: authorization is not yet valid");
        require(now < validBefore, "EIP5828: authorization is expired");
        require(
            !_authorizationStates[from][nonce],
            "EIP5828: authorization is used"
        );

        bytes memory data = abi.encode(
            PERMISSIONLESS_TRANSFER_WITH_AUTHORIZATION_TYPEHASH,
            from,
            to,
            value,
            relayerValue,
            validAfter,
            validBefore,
            nonce
        );
        require(
            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,
            "EIP5828: invalid signature"
        );

        _authorizationStates[from][nonce] = true;
        emit AuthorizationUsed(from, nonce);

        _transfer(from, to, value);
        _transfer(from, msg.sender, relayerValue);
    }
}
```

## Security Considerations

Relayers will need to be cognizant of the risk that the transaction might already be relayed by the time they attempt submission, resulting in a failed on-chain tx which incurs gas costs without any benefit. However, this risk is no different than relayers competing for sandwich opportunities on mempool AMM transactions. 

Using EIP-5828, MEV bots will be competing against each other to relay transactions quickly to acquire the relayer fee. Searchers will need to develop internal systems for figuring out when a specific meta transaction should or should not be relayed, balancing risk of tx revert with the potential reward.  

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
